#include "STC_CPU.H"
#include "main.h"
#include "uart.h"
#include <String.h>

#define S2RI  0x01
#define S2TI  0x02
#define S2RB8 0x04
#define S2TB8 0x08

sbit REL = P2^0;
sbit DEL = P2^1;
sbit RER = P2^2;
sbit DER = P2^3;
//p2.0=0，接收  p2.1  =1 发送  左面
//p2.2=0 ，接收  p2.3 =1  发送 

BYTE g_byT1buf[T1BUF_MAX_LEN];
BYTE g_byR1buf[R1BUF_MAX_LEN];
BYTE g_byBegT1buf,g_byEndT1buf,g_byBegR1buf,g_byEndR1buf;

BYTE g_byT2buf[T2BUF_MAX_LEN];
BYTE g_byR2buf[R2BUF_MAX_LEN];
BYTE g_byBegT2buf,g_byEndT2buf,g_byBegR2buf,g_byEndR2buf;

BYTE rcv_flag,snd_flag,rcv_flag2,snd_flag2;
BYTE Receive[20],Receive2[20];
BYTE rcv_counter,rcv_counter2;  
BYTE rcv_length,rcv_length2;

void rcv_handle2(BYTE rcv);
BYTE check_modbus(void);
BYTE t1_rcvtimeout,t2_rcvtimeout;



void InitUart()
{
	AUXR1 &= 0X7F;		//UART is in P3 port.

	AUXR  &= (~0X04);	//BRT clock is the fosc dived by 12.
//	AUXR  |= 0X11;		//BRT is used as baud generator and start BRT.
	AUXR |=0x1D;

	PCON  &= 0X3F;		//SMOD0=0;
	PCON  |= 0X80;		//SMOD=1
	SCON   = 0x50;		//MODE 1(8 BITS, NO P), RECEIVING PERMIT.

	BRT    = BRT_INI;	//2MHz, 9615.4bpm.

//#if (FOSC/12/16/(256-BRT_INI)-BUAD_RATE)/(BUAD_RATE/100) >= 3
	//BUAD ERROR IS TOO LARGER!
//#endif
	/*
	AUXR1 &= 0x7f;  // UART处于1T工作模式
	AUXR |=0x1D;
	PCON &=0x3f;
	PCON |=0x80;
	SCON =0x50;

	BRT =BRT_INI; //6MHz，9615.4bpm.  */

	ES = 1;
	EA = 1;
	g_byBegT1buf = 0;
	g_byEndT1buf = 0;
	g_byBegR1buf = 0;
	g_byEndR1buf = 0;
}

void InitUart2()
{
	  
   
  	AUXR1 |=0x10;

	//BRT clock is the fosc dived by 12.
	AUXR  |= 0X19;		//BRT is used as baud generator and start BRT.
		
	PCON  |= 0X80;		//SMOD=1
	S2CON   |= 0x50;		//MODE 1(8 BITS, NO P), RECEIVING PERMIT.

	BRT    = BRT_INI;	//2MHz, 9615.4bpm. 

 //#if (FOSC/12/16/(256-BRT_INI)-BUAD_RATE)/(BUAD_RATE/100) >= 3
	//BUAD ERROR IS TOO LARGER!
	/*
	AUXR1 |= 0x10;
	AUXR |= 0x1d;
	PCON |=0x80;
	S2CON |=0x50;

	BRT = BRT_INI; 	*/

	IE2 |= 0x01;

	EA = 1;

	g_byBegT2buf = 0;
	g_byEndT2buf = 0;
	g_byBegR2buf = 0;
	g_byEndR2buf = 0;
}

void Uart() interrupt 4
{	
	if(RI)
	{
		RI = 0;
		Receive[rcv_flag++] = SBUF;	
			
	}

	if(TI)
	{	
		TI = 0;
		if(g_byBegT1buf<g_byEndT1buf)
		{
			SBUF = g_byT1buf[g_byBegT1buf++];
		}
		else
		{
			g_byBegT1buf=g_byEndT1buf=0;
			//RE1=0;//串口1为232
		}  
	}
}



void Uart2() interrupt 8
{ 
	if(S2CON&S2RI)
	{
		S2CON &= ~S2RI;
		Receive2[rcv_flag2++] = S2BUF;
		t2_rcvtimeout = 3; 	
	}

	if(S2CON & S2TI)
	{
		S2CON &= ~S2TI;
		if(g_byBegT2buf<g_byEndT2buf)
		{
			S2BUF = g_byT2buf[g_byBegT2buf++];
		}
		else
		{
			//delay(2);
		   	if (g_byT2buf[g_byEndT2buf] == 0x10)
			{
				REL=0;
				DEL=0;
				RER=1;
				DER=0;
			}
			if (g_byT2buf[g_byEndT2buf] == 0x20)
			{
				RER=0;
				DER=0;  //这时要根据当前是往左、右那个发送的命令，来决定从哪里接收。
				REL=1;
				DEL=0;
			}
			g_byBegT2buf=g_byEndT2buf=0;
		}
	}
}

BYTE DealRcvBuffer(BYTE uartNumber)
{
   	BYTE syn_flag=0;
	BYTE sum=0, jiaoyan=0, i=0;
	BYTE tempbuf[20];
	BYTE RecvBuf[20];
	BYTE rcvCNT = 0;
	BYTE rcv;

  	if (uartNumber == 1) 
	{
		memcpy(RecvBuf,Receive,20);
		rcvCNT = rcv_flag;
		if (RecvBuf[0] != 0xff)  //如果开头不是0xff,那就返回吧
		{
			t1_rcvtimeout = 0;
			return 0;
		}
	}
	else
	{
		memcpy(RecvBuf,Receive2,20);
		rcvCNT = rcv_flag2;
		if (RecvBuf[0] != 0xff)  //如果开头不是0xff,那就返回吧
		{
			t2_rcvtimeout = 0;
			return 0;
		}
	}

	memset(tempbuf,0,20);
	rcv_counter = 0;

	for (i = 1 ; i < rcvCNT ; i++)
	{
		rcv = RecvBuf[i];
		if(rcv!=0xfe)
		{
			if(rcv==0xfd)
			{
				syn_flag=1;
			}
			else
			{
				if(syn_flag==0)
					tempbuf[rcv_counter++]=rcv;
				else
				{
					tempbuf[rcv_counter++]=rcv+0xfd;
					syn_flag=0;
				}
			}					
		}
		else
		{
			if(tempbuf[rcv_counter-2]==0xfd)
			{
				jiaoyan=tempbuf[rcv_counter-1]+0xfd;
				rcv_counter -= 2;
			}
			else
			{
				jiaoyan=tempbuf[rcv_counter-1];
				rcv_counter--;
			}
		}
	}

	for(i=0;i<rcv_counter;i++)
	{
		sum += tempbuf[i];
	}

	if(jiaoyan==sum)
	{
		if (uartNumber == 1)
			memcpy(g_byR1buf,tempbuf,20);
		else
			memcpy(g_byR2buf,tempbuf,20);
		return 1;
	}
	else
	{
		return 0;
	}
}


void rcv_handle2(BYTE rcv)
{
	BYTE bRet=0;
	bRet = DealRcvBuffer(2); //
	if (bRet == 1)
	{
		snd_flag2 = 1;
		t2_rcvtimeout = 0;
	}
	else 
		snd_flag2 = 0;
}


void Send1(BYTE* buf, BYTE len)
{
    BYTE i=0, j=0;

	g_byT1buf[0]=0xff;
	for(i=0;i<len;i++)
	{
		g_byT1buf[j++]=buf[i];
	}
	g_byEndT1buf=j;

	g_byBegT1buf=0;
	SBUF=g_byT1buf[g_byBegT1buf++];		
}

void Send2(BYTE* buf, BYTE len,BYTE channel)
{
    BYTE i=0, j=1, sum=0;

	for(i=0;i<len;i++)
	{
		sum += buf[i];
	}

	g_byT2buf[0]=0xff;
	for(i=0;i<len;i++)
	{
		if(buf[i]<0xfd)
			g_byT2buf[j++]=buf[i];
		else
		{
			g_byT2buf[j++]=0xfd;
			g_byT2buf[j++]=buf[i]-0xfd;
		}	
	}

	if(sum<0xfd)
		g_byT2buf[j++]=sum;
	else
	{
		g_byT2buf[j++]=0xfd;
		g_byT2buf[j++]=sum-0xfd;
	}

	g_byT2buf[j++]=0xfe;
	g_byEndT2buf=j;
    if(channel==0)	//发到左面
	{
		RER=1;
		DER=0;
		REL=1;
		DEL=1;
		g_byT2buf[j++] = 0x10;  //这是往左边发的	 
	}
	else
	{
		REL=1;
		DEL=0;
		RER=1;
		DER=1;	 
		g_byT2buf[j++] = 0x20; //右边
	}  
	g_byBegT2buf=0;
	S2BUF=g_byT2buf[g_byBegT2buf++];		
}

/***********************CRC校验*************************/ 
// CRC 高位字节值表 
unsigned char code auchCRCHi[] = { 
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01,
0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0,
0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01,
0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81,
0x40
} ; 
// CRC低位字节值表 
unsigned char code auchCRCLo[] = { 
0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7, 0x05, 0xC5, 0xC4,
0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E, 0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09,
0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9, 0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD,
0x1D, 0x1C, 0xDC, 0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32, 0x36, 0xF6, 0xF7,
0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D, 0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A,
0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE,
0x2E, 0x2F, 0xEF, 0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1, 0x63, 0xA3, 0xA2,
0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4, 0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F,
0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB,
0x7B, 0x7A, 0xBA, 0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0, 0x50, 0x90, 0x91,
0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97, 0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C,
0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E, 0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88,
0x48, 0x49, 0x89, 0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83, 0x41, 0x81, 0x80,
0x40 
} ; 
unsigned int crc16(unsigned char *puchMsg, unsigned int usDataLen) 
{ 
unsigned char uchCRCHi = 0xFF ; //* 高CRC字节初始化 
unsigned char uchCRCLo = 0xFF ; //* 低CRC 字节初始化 
unsigned long uIndex ; // CRC循环中的索引 
while (usDataLen--) // 传输消息缓冲区 
{ 
uIndex = uchCRCHi ^ *(puchMsg++) ; // 计算CRC 
uchCRCHi = uchCRCLo ^ auchCRCHi[uIndex] ; 
uchCRCLo = auchCRCLo[uIndex] ; 
} 
return (uchCRCHi << 8 | uchCRCLo); 
} 

//该函数对接收缓冲区的MODBUS命令进行CRC验证，如果正确返回1
BYTE check_modbus(void) 
{
	//RECEVIE[0]为地址，[1]为命令，[2]，[3]为地址
	u8 len;
//	u16 crc;
	len = 0;
	if(rcv_flag>7)//超过七个才有必要来计算CRC，这里要注意单片机计算能力有限，不知道能不能正常，请孙祥祥测试
	{ 
		if (Receive[1] == 0x03)
			len = 8;
		if (Receive[1] == 0x01)
			len = 8;
		if (Receive[1] == 0x10)
			len = Receive[5] + Receive[5] + 9;  //这里应该是触摸屏要发来的字节数-2		
		//crc=crc16(Receive,len - 2); //这里可以偷懒不做crc校验
		if (rcv_flag == len )
		{
			rcv_flag = 0;
			memcpy(g_byR1buf,Receive,len);
			memset(Receive,0,20);
			snd_flag = 1;
		}
		else
			snd_flag = 0;
	}
	else
		snd_flag = 0;
	return 	snd_flag;
}